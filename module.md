# Module

В современном мире мы используем множество различных систем для создания конечного кода, большая часть которого может быть переиспользована. Однако, существующие web-технологии предлагают лишь 3 варианта:

1. Создание сборок (bundle), в которые включены все зависимости и повторяются для каждой сборки, в каждом проекте. Пример, webpack, browserify, rollupjs и др.
```
project1
        bundle1
                react, 100kb
                file1
        chunk2
                react, 100kb
                file2

project2
        bundle2
                react, 100kb
                file3
                ```
                
Затраты на загрузку каждого нового модуля остаются прежними. В целом, перезагружается каждый раз до 90% кода.

2. Иерархическая загрузка зависимостей на основе информации об импорте каждого следующего модуля, примеры, systemjs, stealjs, веб-компоненты:
```
load module1, 10ms
        read dependencies
                load module2, 10ms
                        read dependencies, 10ms
                                load module4, 10ms
                load module3, 10ms
```

Затраты по времени на первоначальную загрузку очень большие.

3. Глобальные имена и ручная проверка версий, контекста и т.д. Отсутствие управления суб-зависимостями.

<script src="jquery.2.0.0.min.js"></script>
<script src="bootstrap.min.js"></script>// Какая версия JQuery нужна или подходит?

Затраты на поддержку кодовой базы огромные.

# Два типа модулей

Современные системы позволяют не ограничиваться количеством запросов, websocket существует уже давно, а http2 уже используется повсеместно. А значит, мы можем начать использоваться модульную систему по-настоящему эффективно.

Neweb предлагает 2 типа модулей:

1. Входной модуль (entry-point). Этот модуль должен описывать абсолютно все зависимости и зависимости от зависимостей, которые могут в нем использоваться. Предполагается, что он является стартовой точкой приложения, и позволяет загружать зависимости плоско (flat) и одновременно, вместо иерархической загрузки.

```
project1
        load module1
        read dependencies
                load module2
                ready dependencies!!!
                load module3
                ready dependencies!!!
                load module4
                ready dependencies!!!```

2. Зависимость (dependence). Модуль описывает только собственные зависимости. Не должен, но может использоваться сам по себе.

# Формат модуля

Модуль представляет из себя JS-файл (или кусок кода), оформленный специальным образом. Формат базируется на AMD, но с учетом особенностей Neweb.

Модуль должен начинаться с описания функции define, которая принимает 3 обязательных параметра:

1. Название модуля.
2. Массив зависимостей модуля.
3. Callback-функцию, в теле которой содержится, собственно, код.
```javascript
define(["l",".","index","160903","*"], ["npm",["jquery",["0.0.1",["index",["ajax", "default"]]]]], function(dependencies, require, exports, module){
        var $ = require(dependencies[1]);
        console.log($("#id1").html());
        var jQueryGet = require(dependencies[0]);
        jQueryGet(/*...*/).then(()=>{/*...*/});
})
```    
Предполагается, что модули создаются не вручную, а с помощью различных упаковщиков.

# Наименование модуля

 Neweb предлагает следующий формат именования модулей, основанный на опыте использования существующих систем:

`ТИП,ПАКЕТ,ВЕРСИЯ,ПУТЬ,ЭКСПОРТ`

Надо понимать, что этот формат выведен исключительно эмпирическим путем за долгие годы использования различных систем, и представляет собой обычный многомерный массив для определения полного пути к модулю.

Все параметры являются обязательными.

# Загрузчик

Загрузчик модуля должен реализовывать в глобальном пространстве функцию define и, после получения кода, выполнить его.

Функция define загружает все зависимости данного модуля, после чего модуль считается готовым к require. При первой потребности в модуле, вызывает callback-функцию и передает в нее 4-е параметра:

1. Массив зависимостей (сверху вниз по дереву).
2. require - функция для загрузки зависимости из массива.
3. exports  см. commonjs exports.
4. module - см. commonjs module.

После чего, складывает значение в кэш и отдает его при каждом вызове require. Версионность позволяет кэшировать модули "навсегда". 

Каждый загрузчик модуля волен определять способы загрузки модуля по его имени, это может быть интернет, локальный кэш, вручную введенный код и т.д.

Например, определить, что тип NPM загружается с помощью Ajax по определенному URL (это может быть CDN).
А тип l (local) загружается с помощью вебсокетов.

Очистка кэша возможна на основе версионности или учета давности использования модуля.
